#!/bin/bash

TOP_DIR=..
export PATH=$PATH:$TOP_DIR/functions

source PkgFunctions
source ScriptFunctions
source $TOP_DIR/.config
source $TOP_DIR/functions/Platforms

function cleanup() {
    cd "$TOP_DIR/bin"
    ./BootStrap stop
}

trap cleanup TERM INT STOP HUP


#
# Ensure that dependencies are installed
#
InstallDependencies || exit 1


if [ "$NATIVE_COMPILING" = "y" ]
then export arch_conf="Native"
else export arch_conf=`get_chosen_arch`
fi
    
source $goboSettings/Compile/Cross/Cross-$arch_conf.conf
prefix="$cross_prefix_dir"
kernelVersion="$cross_kernel_version"
symlink_options="-c overwrite"

# needs to be propagated to Scripts
export goboCrossCompiling=yes


#
# Create the basic GoboLinux structure
#
if [ ! -d $prefix/$goboPrograms ]
then
    Log_Normal "Creating the GoboLinux tree..."
    CreateGoboLinuxTree $prefix $SUPER_USER_NAME || exit 1
fi


#
# Since we have $goboDevices bind-mounted, unmount and mount it after
# populating the target dir.
#
umount $prefix/$goboDevices 2> /dev/null

if [ ! -c $prefix/$goboDevices/console ]
then
    Log_Normal "Populating the device directory..."
    PopulateDev $prefix || exit 1
fi

mount -o bind $goboDevices $prefix/$goboDevices


#
# Install the Scripts package
#
dirname="$prefix/$goboPrograms/Scripts"
if [ ! -d "$dirname" -a "$TARGET_EMBEDDED" = "n" ]
then
    Log_Normal "Installing the Scripts package..."
    cp -a $goboPrograms/Scripts $prefix/$goboPrograms
    RescueSymlinkProgram `readlink -f $dirname/Current` $prefix/$goboLinks >& /dev/null
else
    ln -nsf $goboSettings/Scripts $prefix/$goboSettings/Scripts
fi


#
# Install the Compile package
#
dirname="$prefix/$goboPrograms/Compile"
if [ ! -d "$dirname" -a "$TARGET_EMBEDDED" = "n" ]
then
    Log_Normal "Installing the Compile package..."
    cp -a $goboPrograms/Compile $prefix/$goboPrograms
    RescueSymlinkProgram `readlink -f $dirname/Current` $prefix/$goboLinks >& /dev/null
else
    ln -nsf $goboSettings/Compile $prefix/$goboSettings/Compile
fi


#
# Install the BootScripts package
#
dirname="$prefix/$goboPrograms/BootScripts"
if [ ! -d "$dirname" -a "$TARGET_EMBEDDED" = "n" ]
then
    Log_Normal "Installing the BootScripts package..."
    cp -a $goboPrograms/BootScripts $prefix/$goboPrograms
    SymlinkProgram $symlink_options BootScripts >& /dev/null
fi


#
# Create a LibGCC package just to satisfy packages with 
# dependencies on libgcc_s.so
#
dirname="$prefix/$goboPrograms/LibGCC"
if [ "$PKG_LIBGCC" = "y" -a ! -d "$dirname" ]
then
    Log_Normal "Creating the LibGCC package..."
    version=`$CC --version | head -n 1 | awk {'print $3'}`
    gcclibdir=$cross_gcc_libdir

    mkdir -p $dirname/$version/lib
    ln -sf $version $dirname/Current

    Quiet pushd $dirname/Current/lib
    cp -a $gcclibdir/libgcc* .
    for i in *
    do
        # get rid of eventual directories copied together
        [ -d $i ] && rm -Rf $i
    done
    Quiet popd

    SymlinkProgram $symlink_options LibGCC >& /dev/null
fi


#
# Create a LibStdC++ package to satisfy packages with 
# dependencies on libstdc++.so
#
dirname="$prefix/$goboPrograms/LibStdC++"
if [ "$PKG_LIBSTDC" = "y" -a ! -d "$dirname" ]
then
    Log_Normal "Creating the LibStdC++ package..."
    version=`$CC --version | head -n 1 | awk {'print $3'}`
    gcclibdir=$cross_gcc_libdir

    mkdir -p $dirname/$version/lib
    ln -sf $version $dirname/Current

    Quiet pushd $dirname/Current/lib
    cp -a $gcclibdir/libstdc++* .
    for i in *
    do
        # get rid of eventual directories copied together
        [ -d $i ] && rm -Rf $i
    done
    Quiet popd

    SymlinkProgram $symlink_options LibStdC++ >& /dev/null
fi
