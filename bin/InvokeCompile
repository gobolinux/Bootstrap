#!/bin/sh

#
# InvokeCompile: parses .config and runs Compile for each pkg selected there
#
# Author: Lucas Correia Villa Real <lucasvr@gobolinux.org>
#

TOP_DIR=..
dot_config=$TOP_DIR/.config
subdir=$TOP_DIR/packages

# GoboLinux Scripts' functions
source GoboPath
source ScriptFunctions
Import GoboLinux

# Bootstrap's own functions
PATH=$PATH:$TOP_DIR/functions
source PkgFunctions
source BlackList

# Cross-compiling variables
source $dot_config

# TODO: the headers script have shown to be broken on many releases I've tested.
#       we're relying on the existence of a binary package for now.
function make_headers() {
    dirname="$prefix/$goboPrograms/Linux-Libc-Headers"
    [ -d "$dirname" ] && return
	
    Log_Normal "Creating the Libc Headers package..."
    if [ "$CROSS_NONE" = "y" ]
    then
        case `uname -m` in
            i386|i486|i586|i686)
                kernelArch="i386"
                ;;
            *)
                Log_Error "Please add your architecture to this file!"
                exit 1
                ;;
        esac
	else
		kernelArch="$cross_kernel_arch"
    fi

    # Latest release known to work is 2.6.12.0 (based on LFS)
    pushd "$TOP_DIR/bin" >& /dev/null
    ./MakeKernelHeaders 2.6.12 $cross_kernel_arch $dirname
    SymlinkProgram $symlink_options Linux-Libc-Headers
    popd >& /dev/null

    if [ "$CROSS_NONE" = "n" ]
    then
        unset goboCrossCompiling goboPrefix
        Parse_Conf Directories.conf
    fi
}

function download_headers() {
    dirname="$prefix/$goboPrograms/Linux-Libc-Headers"
    [ -d "$dirname" ] && return
	
    Log_Normal "Downloading the Libc Headers package..."
    if [ "$CROSS_NONE" = "y" ]
    then
        case `uname -m` in
            i386|i486|i586|i686)
                repository="http://gobo.calica.com/packages/official"
                cross_uname_m=i686
                ;;
            *)
                Log_Error "Please add your architecture to this file!"
                exit 1
                ;;
        esac
    else
        repository="http://gobo.calica.com/packages/$cross_uname_m"
    fi
    
    # download the headers package
    download_dir="`readlink -f $TOP_DIR/downloads`"
    pushd $download_dir >& /dev/null
    wget -c $repository/Linux-Libc-Headers--2.6.12--$cross_uname_m.tar.bz2
    if [ $? != 0 ]
    then
        Log_Error "Could not download $repository/Linux-Libc-Headers--2.6.12--$cross_uname_m.tar.bz2"
        exit 1
    fi
    popd >& /dev/null
     
    # uncompress it
    pushd "$prefix/$goboPrograms" >& /dev/null
    tar jxvf $download_dir/Linux-Libc-Headers--2.6.12--$cross_uname_m.tar.bz2
    popd >& /dev/null
     
    # symlink it
    [ ! "$CROSS_NONE" = "y" ] && export goboCrossCompiling=yes
    SymlinkProgram $symlink_options Linux-Libc-Headers
    [ ! "$CROSS_NONE" = "y" ] && unset goboCrossCompiling
    [ ! "$CROSS_NONE" = "y" ] && Parse_Conf Directories.conf
}

function chroot_compile() {
    local_recipe="$1"
    
    echo
    Log_Normal "Running 'ChrootCompile --local-repository $cross_options $local_recipe'"
    echo
    
    pushd "$TOP_DIR/chroot" >& /dev/null
    
    common_options="--local-repository $cross_options"
    if [ "$verbose_build" = "1" ]
    then ChrootCompile $common_options --verbose $local_recipe || exit 1
    else ChrootCompile $common_options $local_recipe 2>&1 | grep -v $verbose_filter || exit 1
    fi
    
    export goboCrossCompiling=yes
    SymlinkProgram $pkg_name $pkg_version
    unset goboCrossCompiling
    Parse_Conf Directories.conf
    
    popd >& /dev/null
}

function cleanup() {
    cd "$TOP_DIR/bin"
    ./BootStrap stop
}

trap cleanup TERM INT STOP HUP

# the verbose flag and the keywords which are going to be filtered from stdout
[ "$CC" = "" ] && CC=gcc
[ "$LD" = "" ] && LD=ld

verbose_build=$1
verbose_filter="configure\|checking\|Try\|config.status"
verbose_filter="$verbose_filter\|Making\|Entering\|Leaving\|Nothing\|$CC\|$LD"
verbose_filter="$verbose_filter\|/bin/make\|gawk"
verbose_filter="$verbose_filter\|mkinstalldirs\|install"

if [ "$verbose_build" = "1" ]
then Log_Terse "Verbose build enabled"
else Log_Terse "Verbose build disabled"
fi

if [ "$CROSS_NONE" = "y" ]
then 
    prefix="$INSTALL_PREFIX"
else
    [ "$CROSS_ARM"  = "y" ] && export arch_conf=ARM
    [ "$CROSS_SH4"  = "y" ] && export arch_conf=SH4

    # this is the same as evaluating the line 'export cross_prefix_dir=...'
    `cat $goboSettings/Compile/Cross-$arch_conf.conf | grep "cross_prefix_dir=" | sed 's/\"//g'`
    `cat $goboSettings/Compile/Cross-$arch_conf.conf | grep "cross_kernel_arch=" | sed 's/\"//g'`
    `cat $goboSettings/Compile/Cross-$arch_conf.conf | grep "cross_kernel_version=" | sed 's/\"//g'`
    prefix=$cross_prefix_dir

    cross_options="--cross-compile $arch_conf"
    symlink_options="-c overwrite"

    export cross_compiling=yes
fi

skip_all=0
pushd $subdir >& /dev/null

for entry in `cat $dot_config | grep "=y" | grep PKG`
do
    pkg_dir=`package_subdir $entry`
    [ ! -d "$pkg_dir" ] && { Log_Error "$pkg_dir not found"; continue; }

    pkg_name=`basename "$pkg_dir"`
    is_in_blacklist "$pkg_name" && { Log_Error "$pkg_name is in blacklist"; continue; }
    
    # If a hook is configured for the current package, execute it
    # so that a specific version can be used. Hooks are declared
    # inside functions/PkgFunctions.
    hook_function="`echo ${pkg_name} | sed 's/-/_/g'`_hook"
    pkg_version=`${hook_function} 2> /dev/null`

    if [ -d "$prefix/$goboPrograms/$pkg_name" ]
    then
        if [ $skip_all = 1 ]
        then
            Log_Normal "Skipping package $pkg_name"
            continue
        fi

        Ask_Option "$pkg_name seems to be already compiled. Do you want to skip it? [Y(es)/N(o)/SA(skip all)]"
        case "$REPLY" in
            n|N)  # compile it
                  ;;
            sa|SA) # skip all
                  skip_all=1
                  continue
                  ;;
            *)    continue 
                  ;;
        esac
    fi
 
#	recipe=`get_recipe "$pkg_dir" "$pkg_name" $pkg_version`
    recipe=`FindPackage -t recipe $pkg_name $pkg_version`
    echo $recipe | grep -q "^http" && local_recipe=`GetRecipe $recipe` || local_recipe=$recipe
    
    chroot_compile $local_recipe

    # And here is the final trick: if we have just compiled Glibc, create the
    # Linux-Libc-Headers package, as it needs to be compiled with raw kernel headers.
    [ "$pkg_name" = "Glibc" ] && download_headers
done

popd >& /dev/null
