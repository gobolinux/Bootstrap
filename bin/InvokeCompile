#!/bin/sh

#
# InvokeCompile: parses .config and runs Compile for each pkg selected there
#
# Author: Lucas Correia Villa Real <lucasvr@gobolinux.org>
#

TOP_DIR=..

PATH=$PATH:$TOP_DIR/functions:$TOP_DIR/chroot
dot_config=$TOP_DIR/.config
subdir=$TOP_DIR/packages

# GoboLinux Scripts' functions
source GoboPath
source ScriptFunctions
Import GoboLinux

# Bootstrap's own functions
source PkgFunctions
source BlackList
source $TOP_DIR/functions/Platforms

# Cross-compiling variables
source $dot_config


# TODO: the headers script have shown to be broken on many releases I've tested.
#       we're relying on the existence of a binary package for now.
function make_headers() {
    dirname="$prefix/$goboPrograms/Linux-Libc-Headers"
    [ -d "$dirname" ] && return
	
    Log_Normal "Creating the Libc Headers package..."
    if [ "$NATIVE_COMPILING" = "y" ]
    then
        case `uname -m` in
            i386|i486|i586|i686)
                kernelArch="i386"
                ;;
            *)
                Log_Error "Please add your architecture to this file!"
                exit 1
                ;;
        esac
    else
        kernelArch="$cross_kernel_arch"
    fi

    pushd "$TOP_DIR/bin" >& /dev/null
    ./MakeKernelHeaders "$KERNEL_HEADERS_VERSION" $kernelArch $dirname
    popd >& /dev/null

    [ "$NATIVE_COMPILING" != "y" ] && export goboCrossCompiling=yes
    SymlinkProgram $symlink_options Linux-Libc-Headers
    [ "$NATIVE_COMPILING" != "y" ] && unset goboCrossCompiling goboPrefix
    [ "$NATIVE_COMPILING" != "y" ] && Parse_Conf Directories.conf
}

function download_headers() {
    dirname="$prefix/$goboPrograms/Linux-Libc-Headers"
    [ -d "$dirname" ] && return
	
    Log_Normal "Downloading the Libc Headers package..."
    if [ "$NATIVE_COMPILING" = "y" ]
    then
        case `uname -m` in
            i386|i486|i586|i686)
                repository="http://gobo.calica.com/packages/official"
                uname_m=i686
                ;;
            *)
                Log_Error "Please add your architecture to this file!"
                exit 1
                ;;
        esac
    else
        repository="http://gobo.calica.com/packages/$uname_m"
    fi
    
    # download the headers package
    download_dir="`readlink -f $TOP_DIR/downloads`"
    pushd $download_dir >& /dev/null
    wget -c $repository/Linux-Libc-Headers--2.6.12--$uname_m.tar.bz2
    if [ $? != 0 ]
    then
        Log_Error "Could not download $repository/Linux-Libc-Headers--2.6.12--$uname_m.tar.bz2"
        exit 1
    fi
    popd >& /dev/null
     
    # uncompress it
    pushd "$prefix/$goboPrograms" >& /dev/null
    tar jxvf $download_dir/Linux-Libc-Headers--2.6.12--$uname_m.tar.bz2
    popd >& /dev/null
     
    # symlink it
    [ "$NATIVE_COMPILING" != "y" ] && export goboCrossCompiling=yes
    SymlinkProgram $symlink_options Linux-Libc-Headers
    [ "$NATIVE_COMPILING" != "y" ] && unset goboCrossCompiling goboPrefix
    [ "$NATIVE_COMPILING" != "y" ] && Parse_Conf Directories.conf
}

function download_meta() {
    unset is_meta
    unset include
    arch=`Get_Architecture $uname_m`

    source $1/Recipe
    [ -f $1/$arch/Recipe ] && source $1/$arch/Recipe
    if [ "$is_meta" = "yes" ]
    then
        for pkgver in "${include[@]}"
        do
            ipkg="${pkgver%--*}"
            ver="${pkgver#*--}"

            # fetch the included recipes
            Log_Normal "Checking for included recipe $ipkg $ver..."
            rcp=`FindPackage -W -t recipe $ipkg $ver`
            if [ -z "$rcp" ]
            then
                rcp=`FindPackage -t recipe $ipkg $ver` || exit 1
            fi
            if echo $rcp | grep -q "^http"
            then
                Log_Normal "Getting included recipe $ipkg $ver..."
                rcp=`GetRecipe $rcp` || exit 1
            fi
            download_meta $rcp
        done
    fi
}

function chroot_compile() {
    local_recipe="$1"

    # check if needs to download meta recipes
    download_meta $local_recipe

    echo
    Log_Normal "Running 'ChrootCompile --local-repository $cross_options $local_recipe'"
    echo
    
    pushd "$TOP_DIR/chroot" >& /dev/null
    
    common_options="--local-repository $cross_options"
    if [ "$verbose_build" = "1" ]
    then ChrootCompile $common_options --verbose $local_recipe || exit 1
    else ChrootCompile $common_options $local_recipe || exit 1
    #else ChrootCompile $common_options $local_recipe 2>&1 | grep -v $verbose_filter || exit 1
    fi
    
    [ "$NATIVE_COMPILING" != "y" ] && export goboCrossCompiling=yes
    UpdateSettings --quick $pkg_name $pkg_version
    SymlinkProgram $pkg_name $pkg_version
    [ "$NATIVE_COMPILING" != "y" ] && unset goboCrossCompiling && Parse_Conf Directories.conf
    
    popd >& /dev/null
}

function cleanup() {
    cd "$TOP_DIR/bin"
    ./BootStrap stop
    exit 0
}

trap cleanup TERM INT STOP HUP

# the verbose flag and the keywords which are going to be filtered from stdout
[ "$CC" = "" ] && CC=gcc
[ "$LD" = "" ] && LD=ld

verbose_build=$1
verbose_filter="configure\|checking\|Try\|config.status"
verbose_filter="$verbose_filter\|Making\|Entering\|Leaving\|Nothing\|$CC\|$LD"
verbose_filter="$verbose_filter\|/bin/make\|gawk"
verbose_filter="$verbose_filter\|mkinstalldirs\|install"

if [ "$verbose_build" = "1" ]
then Log_Terse "Verbose build enabled"
else Log_Terse "Verbose build disabled"
fi

if [ "$NATIVE_COMPILING" = "y" ]
then 
    prefix="$INSTALL_PREFIX"
    export uname_m=`uname -m`
else
    export arch_conf=`get_chosen_arch`

    # this is the same as evaluating the line 'export cross_prefix_dir=...'
    `cat $goboSettings/Compile/Cross/Cross-$arch_conf.conf | grep "cross_prefix_dir=" | sed 's/\"//g'`
    `cat $goboSettings/Compile/Cross/Cross-$arch_conf.conf | grep "cross_kernel_arch=" | sed 's/\"//g'`
    `cat $goboSettings/Compile/Cross/Cross-$arch_conf.conf | grep "cross_kernel_version=" | sed 's/\"//g'`
    `cat $goboSettings/Compile/Cross/Cross-$arch_conf.conf | grep "cross_uname_m=" | sed 's/\"//g'`
    prefix=$cross_prefix_dir

    cross_options="--cross-compile $arch_conf"
    symlink_options="-c overwrite"

    export uname_m="$cross_uname_m"
    export cross_compiling=yes
fi

skip_all=0
pushd $subdir >& /dev/null

for entry in `cat $dot_config | grep ^PKG_`
do
    pkg_dir=`package_subdir $entry`
    [ ! -d "$pkg_dir" ] && { Log_Error "$pkg_dir not found"; continue; }

    pkg_name=`basename "$pkg_dir"`
    is_in_blacklist "$pkg_name" && { Log_Error "$pkg_name is in blacklist"; continue; }
    
    # If a hook is configured for the current package, execute it
    # so that a specific version can be used. Hooks are declared
    # inside functions/PkgFunctions.
    hook_function="`echo ${pkg_name} | sed 's/-/_/g'`_hook"
    pkg_version=`${hook_function} 2> /dev/null`

    if [ -d "$prefix/$goboPrograms/$pkg_name" ]
    then
        if [ $skip_all = 1 ]
        then
            Log_Normal "Skipping package $pkg_name"
            continue
        fi

        Ask_Option "$pkg_name seems to be already compiled. Do you want to skip it? [Y(es)/N(o)/SA(skip all)]"
        case "$REPLY" in
            n|N)  # compile it
                  ;;
            sa|SA) # skip all
                  skip_all=1
                  continue
                  ;;
            *)    continue 
                  ;;
        esac
    fi
 
    recipe=`FindPackage -t recipe $pkg_name $pkg_version`
    echo $recipe | grep -q "^http" && local_recipe=`GetRecipe $recipe` || local_recipe=$recipe
    [ -z "$local_recipe" ] && Log_Error "Could not find recipe for $pkg_name" && exit 1

    chroot_compile $local_recipe

    # And here is the final trick: if we have just compiled Glibc, create the
    # Linux-Libc-Headers package, as it needs to be compiled with raw kernel headers.
    if [ "$pkg_name" = "Glibc" ]
    then [ "$NATIVE_COMPILING" = "y" ] && make_headers || download_headers
    fi
done

popd >& /dev/null
